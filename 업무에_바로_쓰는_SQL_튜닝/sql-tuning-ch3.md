## SQL 튜닝 실행 계획 파헤치기
	
### 실행 계획 수행
실행 계획이란 sql 을 통해 요청한 데이터를 어떻게 가져올 것인지에 대한 계획 혹은 경로이다.<br/>
지름길을 통해 데이터를 빠르게 찾아내고 있는지, 지름길을 두고 멀리 돌아가는지를 확인하기 위해 사용한다. <br/>

mysql 의 경우 옵티마이저가 만들어 낸 실행계획을 볼 수 있다.


#### 기본 실행 계획 수행
실행 계획을 확인하는 키워드

```sql
//어떤 키워드를 사용해도 결과는 같다.

EXPLAIN sql문;
DESCRIBE sql문;
DESC sql문;
``` 

#### MySQL, MariaDB 실행 계획 수행
- SQL문 앞에 `EXPLAIN`을 추가하면 옵티마이저가 만든 시행 계획이 출력된다.
```sql
EXPLAIN
	select * from 사원
	where 사원번호 between 100001 AND 200000;
```

- MariaDb 10.0.5 이상부터 `update`, `delete` 문에서도 실행계획 확인 가능하다.

##### id
- SQL문이 수행되는 차례(순서)를 ID 표기한 것
- `id`가 작을수록 먼저 수행된 것이고 `id`가 같다면 `join`이 발생한 것으로 해석 가능하다.

##### select_type
- select 문의 유형을 출력하는 항목
- select 문이 `from` 절의 것인지, `서브쿼리` 인지, `Union` 으로 묶인 select 문인지 등의 정보

- `SIMPLE` 
  - 가장 단순한 `select` 구문
- `PRIMARY`
  - `서브쿼리가 포함된 SQL문`에서 `첫번째 select 문`에 대한 표시
  - 서브쿼리를 감싸는 외부쿼리 or Union이 포함된 SQL문의 첫번째 select문
  - ex) select 절에 스칼라 서브쿼리가 포함된 경우 외부 쿼리의 테이블에 먼저 접근한다는 의미의 `Primary`
  - `union all` 의 경우에도 통합된 sql 에서 먼저 접근된 테이블이 PARIMARY 로 출력된다.
- `SUBQUERY`
  - 독립적으로 수행되는 서브쿼르
  - select 절 스칼라 서브쿼리, where 절 중첩 서브쿼리에 해당
- `DERIVED`
  - FROM 절에 작성된 서브쿼리 (`인라인 뷰`)
- `UNION`
  - `Union`, `Union all` 로 합쳐진 select 문에서 첫번째 select를 제외한 나머지 select 절에 해당
  - Union 절의 첫번째 select 문은 `Primary`에 해당한다.
- `UNION RESULT`
  - `Union ALL`이 아닌 `UNION`으로 결합했을 때 출력된다.
  - `UNION RESULT` 는 튜닝 포인트이다. (아래 참고)
```
UNION ALL 이 아닌 UNION 으로 select 절 결합시 UNION 의 특성인 유일성으로 인해 select 절에서 데이터를 가져와 정렬 후 중복을 제거하는 과정을 거쳐야 한다.

이 때 정렬 등의 작업은 메모리 혹은 디스크에 임시 테이블을 만들어 수행한다.

위와 같은 작업으로 인한 성능저하 때문에 UNION 으로 결합시 중복이 제거가 필요없다면 UNION 보다는 UNION ALL 을 사용해서 튜닝을 진행한다.
```
- `DEPENDENT SUBQUERY`
  - `Union`, `Union ALL`을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우에 해당
  - `Union`으로 연결되는 `서브쿼리의 첫번째 select`에 해당한다.
  - `Union`을 사용하는 서브쿼리들이 메인 테이블로부터 값을 하나씩 공급받는 구조이기 때문에 성능적으로 불리하여 `튜닝의 대상`이 된다.
- `DEPENDENT UNION`  
  - `Union`으로 연결되는 `서브쿼리의 첫번째 이후 select`에 해당한다.
  - `DEPENDENT SUBQUERY`와 마찬가지로 메인 테이블로부터 값을 하나씩 공급받는 구조이기 때문에 튜닝의 대상이 된다.
- `UNCACHEABLE SUBQUERY`
  - 메모리에 상주하며 재활용 될 서브쿼리야 재사용되지 못할 때 출력된다.
  - 해당 서브쿼리 안에 사용자 정의 함수(`RAND()`, `UUID()`), 사용자 정의 변수가 포함된 경우
  - 자주 호출되는 SQL문이라면 서브쿼리의 결과를 메모리에 상주시키는 방향으로 튜닝 가능하다.
- `MATERIALIZED`
  - `IN` 절에 사용된 서브쿼리가 임시 테이블을 만들어서 조인 작업을 수행할 때 출력된다.
```sql
[ in절에서 급여 테이블을 임시테이블로 만들고 사원 테이블과 조인을 수행 ]
EXPALIN
select * from 사원
where 사원번호 IN (SELECT 사원번호 FROM 급여 WHERE 시작일자 > '2020-01-01');
```  

##### table
- 테이블명을 표시하는 항목 (테이블명 or 테이블 별칭)
- 서브쿼리나 임시테이블의 경우 `<subquery#>` , `<derived#>` 으로 출력된다.

##### partitions
- 실행 계획의 부가정보로 데이터가 저장된 논리적인 영역을 표시하는 항목이다.
- 전체 파티션에 접근하는 것보다 사전에 정해진 특정 파티션에 접근하는 것이 성능상 유리하다.
- 너무 많은 파티션에 접근하는 것으로 출력되면 파티션 정의에 대한 튜닝을 고려해야 한다.

#### type
- 테이블의 `데이터를 어떻게 찾을지`에 관한 정보를 제공하는 항목이다.
- 테이블의 처음부터 끝까지 전부 스캔할 것인지, 인덳를 통해 데이터를 찾아갈지 등을 해석

- `system`
  - 테이블에 데이터가 없거나, 한 개만 있는 경우 (성능상 최상의 type)
- `const`
  - 1건의 데이터만 출력되는 유형
  - 고유 인덱스 or 기본키를 이용해서 빠르게 1건의 데이터에만 접근하므로 성능상 매우 유리
- `eq_ref`
  - 조인시 기본 키나 고유 인덱스를 사용해서 1건의 데이터에만 접근하는 경우이다. 
  - `드라이빙 테이블`과의 조인 키가 `드리븐 테이블`에 유일해서 조인 시 성능상 가장 유리한 경우이다.
```sql
EXPALIN
select 매핑.사원번호, 부서.부서번호, 부서.부서명
from 부서사원_매핑 as 매핑, 부서
where 매핑.부서번호 = 부서.부서번호 AND 매핑.사원번호 BETWEEN 100 AND 110;
```
- `ref`
  - 조인시 드리븐 테이블의 접근범위가 2개 이상일 경우이다. (기본키, 고유 인덱스, 비고유 인덱스 모두 포함)
  - 드리븐 테이블의 양이 많아진다면 성능저하 여부를 확인해야 한다.
```sql
EXPLAIN
select 사원.사원번호, 직급.직급명
from 사원, 직급
where 사원.사원번호 = 직급.사원번호
      and 사원.사원번호 between 1001 and 10100;

EXPLAIN
select *
from 사원
where 입사일자 = '2022-01-01';      
```
- `ref_or_null`
  - `IS NULL` 에 대해 인덱스가 활용되도록 최적화된 방식이다.
    - mysql, mariadb 는 null에 대해서도 인덱스 활용 가능하다. 이 때 null 은 가장 앞 쪽에 정렬된다.
  - 테이블에 null 데이터 양이 적은 경우 `ref_or_null` 효율적인 실행계획이지만, null 이 많은 경우 튜닝의 대상으로 생각하자.
  - `해당 테이블에 null 데이터 양이 많은 경우 튜닝의 대상`
```sql
select *
from 사원출입기록
where 출입문 IS NULL or 출입문 = 'A';
```
- `range`
  - 테이블 내 연속된 데이터가 조회되는 경우
    - `=, <>, >, >= ..., IS NULL, BETWEEN, IN` 등으로 범위 스캔시
  - 스캔 범위가 너무 넓은 경우 튜닝 검토
- `fulltext`
  - 텍스트 검색을 빠르게 처리하기 위해 전문 인덱스를 사용하는 방식
```
//todo
전문검색?

```    
- `index`
  - 인덱스 풀스캔
  - 테이블 풀스캔(`ALL`) 보다는 좋을 가능성이 있다.
- `all`
  - 활용할 수 있는 인덱스가 없거나, 인덱스를 활용하는 것이 오히려 비효율적이라고 옵티마이저가 판단한 경우에 해당한다.
  - 이런 경우 인덱스를 추가하거나 기존 인덱스가 사용될 수 있도록 변경하는 것을 고려할 수 있다.
  - 전체 테이블 중 10~20% 데이터만 조회되는 경우 `ALL` 의 성능이 오히려 유리할 수도 있다.

#### possible_keys
- 옵티마이저가 사용할 수 있는 인덱스의 목록을 출력한다.
- 실제 사용되는 인덱스는 아니다.

#### key
- 옵티마이저가 사용한 기본키 또는 인덱스를 출력한다.

#### ref
- 테이블 조인 수행시 어떤 조건으로 테이블에 엑세스 했는지에 대한 정보이다.

#### rows
- sql 문 수행시 접근하는 모든 해으이 수를 출력한다.
- 실제 출력될 행의 수는 아니다.
- sql 의 최종 결과에 비해 rows 가 너무 크다면 튜닝 대상이 될 수 있다.

#### extra
sql 을 어떻게 수행할 것인지에 대한 추가정보를 출력한다.<br/>
추가정보는 세미콜론으로 구분되어 나열된다.<br/>

- `Distinct`
  - 중복 제거시 출력되는 정보이다.
  - 보통 distinct, union 등 중복제거가 포함되는 연산시 출력된다.
- `Using where`
  - where 절을 통한 필터링 시 출력된다.
- `Using temporary`
  - 데이터의 중간 결과를 임시테이블에 저장하고 정렬 등을 작업을 수행시 출력된다.
  - 보통 `distinct`, `group by`, `order by` 등이 포함된 경우 출력된다.
  - 임시 테이블을 메모리에 생성하는 `Using temporary` 는  튜닝의 대상이 될 수 있다.
- `Using index`
  - 물리적인 데이터 파일을 읽지 않고 인덱스만을 읽어서 sql 문을 처리한 경우 출력된다.
  - `커버링 인덱스` 방식이라고 불린다.
  - 인덱스로만 구성된 열만을 sql 문에서 사용하기 때문에 물리적인 테이블보다 작고 정렬되어 있는 인덱스만을 사용할 수 있으므로 효율적이다.
- `Using filesort`
  - 정렬이 필요한 경우 메모리에 올려 정렬작업을 수행하는 경우 출력된다.
  - 인덱스를 사용하는 경우 이미 인덱스는 이미 정렬되었기 때문에 추가 정렬작업이 필요없지만, 인덱스를 타지 못하는 경우 메모리에 정렬을 수행하게 된다.
- `Using index condition`
  - `Using where` 의 경우 mysql 엔진에서 필터링을 수행하는 반면 `Using index condition` 은 스토리지 엔진에서 필터링을 수행하면서 mysql 엔진에 부하를 줄이는 방식이다.
  - 스토리지 엔진 -> mysql 엔진 으로 데이터 전송양을 줄여 성능을 높일 수 있는 옵티마이저의 최적화 방식이다.