sql-tuning-ch2

## SQL 튜닝 용어를 직관적으로 이해하기 

### 물리 엔진과 오브젝트 용어 
- DBMS를 구성하는 엔진, 내부 프로세스, 데이터를 저장하는 오브젝트 등의 용어

#### DB 엔진 용어
DBMS가 요청받은 SQL을 처리하는 과정 
1. SQL 문을 실행한다. 
2. DB엔진은 실행된 SQL문에 문법에러가 있는지, SQL실행 대상이 현재 DB에 존재하는 테이블 인지 등 세부사항을 검사한다. => Parser의 역할
3. 요청한 데이터를 빠르게 찾기 위한 전략적 계획을 수립한다. => Optimizer의 역할
4. 수립된 계획에 따라 스토리지에 위친한 데이터를 찾고, 찾은 결과를 MySQL 엔진에 전달한다.
5. MySQL 엔진은 전달받은 데이터를 필터링하고 필요한 연산을 수행하여 사용자에게 반환한다.

#### 스토리지 엔진
- `InnoDB`, `MyISAM`, `Memory` ...
- 요청된 SQL을 토대로 디스크나 메모리에서 필요한 데이터를 가져오는 역할을 수행한다.
  가져온 데이터는 다시 MySQL 엔진으로 전달한다.
- 각 스토리지 엔진의 저장방식이 다를 수 있고 상황에 따라 스토리지 엔진을 선택하여 사용할 수 있다.
- `InnoDB`: 온라인 상의 트랜잭션을 처리하는 OLTP 환경에서 사용되는 스토리지 엔진
- `MyISAM`: 대량의 쓰기 트랜잭션이 발생되는 경우 사용되는 스토리지 엔진
- `Memory`: 읽기 성능에서 효과를 내기 위한 스토리지 엔진

#### MySQL 엔진
- 사용자로부터 넘겨받은 SQL에 대한 문법 검사 및 세부사항 검사 
- SQL을 최소단위로 분리해서 빠르게 데이터를 찾을 수 있는 경로를 모색 => 옵티마이저 (실행계획 수립)
- 스토리지 엔진으로부터 받아온 데이터를 대상으로 필터링을 수행하고 필요한 연산을 수행

```
SQL 처리를 택시에 비유
첫번째 손님: 아랍어로 목적지를 말함
  - 아랍어를 알아들을 수 없으므로 운행 불가
두번째 손님: "뉴욕으로 가주세요."
  - 우리나라에는 뉴욕이라는 도시가 없으므로 운행 불가  
세번째 손님: "서울 강남으로 가주세요."
  - OK
  - 목적지가 존재하므로 경로에 대한 모색 후 운행  
```

#### SQL 문 수행절차
1. 사용자가 SQL문 실행
2. 파서(Parsor)가 요청된 SQL문을 최소단위로 분리 후 전처리기에 전달
3. 전처리기는 최소단위로 분리된 구성요소로 권한 및 대상 객체 존재여부를 확인
4. 옵티마이저에 의해 실행계획이 수립되고 수립된 실행계획으로 스토리지 엔진을 호출
5. 스토리지 엔진에서 가져온 데이터를 엔진 실행기에서 필터링 및 연산 수행 후 사용자에게 결과 전달
( 파서 -> 전처리기 -> 옵티마이저 -> 엔진 실행기 )

#### 옵티마이저
- MySQL의 핵심엔진 (DBMS의 두뇌)
- 불필요한 조건 제거 및 연산과정 단순화
- 테이블 접근 순서
- 인덱스 사용 여부
```
실행계획을 수립하는 것 만으로 리소스를 점유하는 작업이다.
또한, 옵티마이저의 모든 실행계획이 최적으로 실행계획은 아닐 수 있다.
```

#### 고유 인덱스
- 인덱스를 구성하는 열의 모든 데이터가 유일하다. (중복 x)
  만약 중복이 발생한다면 고유 인덱스 중복 체크 과정에서 에러를 발생시킨다.
- 인덱스가 새로 추가되어 정렬을 수행할 때 중복체크를 수행  
```sql
학번을 PK로 하는 학생 테이블에서 연락처를 조회하는 일이 빈번한 경우
연락처를 대상으로 고유 인덱스를 생성한다.

ALTER TABLE 학생
ADD UNIQUE INDEX TEL_IDX(TEL);
```

#### 비고유 인덱스
- 데이터가 새로 입력되어 인덱스가 재정렬되더라도 중복체크를 하지 않는다.
```sql
ALTER TABLE 학생
ADD INDEX TEL_IDX(TEL);
```

#### 뷰 View
- `학생 테이블`에 (학번, 이름, 생년월일, 연락처 ...) 등의 칼럼이 있는 경우
- `학생_뷰` 라는 뷰를 생성하고 학번과 이름, 연락처만 조회되도록 생성한다.
- `학생 테이블`에서 데이터가 변경되면 `학생_뷰`에서도 변경된 데이터가 조회된다.
  반대로 `학생_뷰`에서 변경된 데이터도 `학생 테이블`에 반영된다.
- `학생 테이블`에 공개하고 싶지 않은 정보가 있다면 뷰를 통해 제한된 정보만을 제공해서 *보안적*으로 운용할 수 있다.
```sql
CREATE VIEW 학생_뷰 as
	SELECT 학번, 이름, 연락처 
	FROM 학생;
```  

### 서브쿼리
- `SELECT` 내부에 `SELECT` 를 추가 작성한 형태이다.
- 서브쿼리 종류
  - SELECT 절 서브쿼리 (스칼라 서브쿼리)
  - FROM 절 서브쿼리 (인라인 뷰)
  - WHERE 절 서브쿼리 (중첩 서브쿼리)

#### 스칼라 서브쿼리 (SELECT 절 서브쿼리)
- 가장 바깥의 SELECT 절에 해당하는 메인쿼리 SELECT 절에 또 다른 SELECT 절이 있는 형태이다.
- 스칼라 서브쿼리의 결과는 1행 1열의 구조여야 한다. (한 개 컬럼)
- 스칼라 서브쿼리는 보통 집계함수와 함께 사용된다. (max, min, avg, sum, count ...)
```sql
SELECT 이름
	(SELECT COUNT(*)
		FROM 학생 as 학생2
		WHERE 학생2.이름 = 학생1.이름) 카운트
FROM 학생 as 학생1;	
```  

#### 인라인 뷰 (FROM 절 서브쿼리)
- 메인쿼리의 FROM 절에 위치한 SELECT 절 
- 일시적으로 View를 생성하는 방식이다.
```sql
SELECT 학생2.학번, 학생2.이름
FROM (SELECT * 
		FROM 학생
		WHERE 성별='남') 학생2;
```

#### 중첩 서브쿼리 (Where 절 서브쿼리)
- 메인쿼리의 Where 절에 위치한 SELECT 절
```sql
SELECT *
FROM 학생
WHERE 학번 = (SELECT MAX(학번)
				FROM 학생)
```

#### 비상관 서브쿼리
- 메인쿼리와 서브쿼리 간 관계성이 없는 경우에 해당
- 서브쿼리가 독립적으로 먼저 실행되고 그 결과를 메인쿼리에 결과를 던져주는 형태
```sql
SELECT *
FROM 학생
WHERE 학번 IN (SELECT 학번
				FROM 학생
				WHERE 성별 = '남');
```
- 옵티마이저에 따라서 서브쿼리가 제거되고 하나의 메인쿼리로 통합되는 뷰 병합이 발생할 수 있다.

#### 상관 서브쿼리
- 서브쿼리가 수행되기 위해 메인쿼리의 값을 필요로하는 경우에 해당
  (SELECT 절 스칼라 서브쿼리 or WHERE 절 중첩 서브쿼리)
```sql
SELECT *
FROM 학생
WHERE 학번 IN (SELECT 학번
				FROM 지도교수
				WHERE 학생.학번 = 지도교수.학번);
```  

### 조인 Join
- Inner Join
- Left Outer Join / Right Outer Join
- Full Outer Join (MySQL, MariaDB 지원 x)
- Cross Join
- Natural Join

#### Innter Join
- 교집합
```sql
[ 명시적 조인 ]
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생
	JOIN 지도교수
	ON 학생.학번 = 지도교수.학번;

[ 묵시적 조인 ]
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생, 지도교수
	where 학생.학번 = 지도교수.학번;
```
- 명시적 조인, 묵시적 조인 모두 같은 결과를 출력한다.

#### Left Outer Join
- 왼쪽을 기준으로 나중에 오른쪽 테이블을 조인
  - 조인 조건과 일치하지 않더라도 왼쪽 테이블의 결과에 포함된다. 
    (일치하지 않는 오른쪽 부분은 null로 채워버림)
```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생
	LEFT [OUTER] JOIN 지도교수
	ON 학생.학번 = 지도교수.학번;
```  
- 조인의 방향을 반대로 바꾼 Right Outer Join도 가능하다.
- 대부분의 경우 사람은 왼쪽에서 오른쪽으로 인식하므로 Right Outer Join을 Left로 변경해서 일관성 있는 쿼리를 작성하는 것이 관리 측면에서 유리하다.

```sql
SELECT *
	FROM B_테이블
	RIGHT JOIN A_테이블 ON B_테이블.fk = A_테이블.pk;

SELECT *
	FROM A_테이블
	LEFT JOIN B_테이블 ON A_테이블.pk = B_테이블.fk;
```

#### Cross Join
- 조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 반환
- 학생[1,2,3,4] / 지도교수[1,2,4,99] => Cross Join 수행
  - 4 * 4 = 16 (총 16개 row를 반환)
```sql
[ 명시적 Cross Join ]
SELECT 학생.학번, 학생.이름, 지도교수.학번, 지도교수.교수명
	FROM 학생
	CROSS JOIN 지도교수

[ 묵시적 Cross Join ]
SELECT 학생.학번, 학생.이름, 지도교수.학번, 지도교수.교수명
	FROM 학생, 지도교수
```
- Join 없이 두 개 테이블을 From 절에 명시하면 묵시적으로 교차조인이 발생한다.

#### Natural Join
- 두 테이블의 칼럼명이 동일한 경우 Join 절을 작성하지 않아도 자동으로 조인을 수행한다.
- 조인의 결과는 내부 조인과 동일하다.
```sql
SELECT 학생.*, 지도교수.*
FROM 학생
NATURAL JOIN 지도교수;
```
- 자연조인을 실행했는데 두 테이블 간 동일한 칼럼명이 없다면 교차조인을 수행한다.
- 동일한 컬럼명이 있는 경우 => 해당 컬럼으로 내부조인 수행 
- 동일한 칼럼며이 없는 경우 => 교차조인



### Join 알고리즘
- 다수 테이블을 대상으로 Join을 수행할 때 동시에 여러 개 테이블에 접근할 수 없으므로 우선순위를 정하게 된다.
- 각 테이블에 접근하는 선후관계에 따라 `드라이빙 테이블`과 `드리븐 테이블` 로 구분된다.

#### 드라이빙 테이블, 드리븐 테이블
- 드라이빙 테이블: Join 시 두 테이블에 동시에 접근할 수 없는 경우 머저 접근되는 테이블이다.
- 드리븐 테이블: 드라이빙 테이블의 결과를 조회되는 테이블이다.
```sql
select 학생.학번, 학생.이름, 비상연락망.관계, 비상연락망.연락처
from 학생
JOIN 비상연락망
	ON 학생.학번 = 비상연락망.학번
WHERE 학생.학번 IN (1, 100);
```
- 위 쿼리는 학생 테이블과 비상연락망 테이블을 대상으로 Join을 수행한다.
- 먼저 `Where`문에 의해서 학생 테이블을 조회하고 그 결과로 비상연락망 테이블과의 Join을 수행한다.
  여기서 `드라이빙 테이블`은 학생 테이블이 되고, `드리븐 테이블`은 비상연락망 테이블이 된다.
- `드라이빙 테이블`의 결과로 `드리븐 테이블`에 접근하기 때문에 `드라이빙 테이블`을 어떤 테이블로 선정할 지는 중요한 문제이다.

#### 중첨 루프 조인 (NL Join, nested look join)
- `드라이빙 테이블`의 데이터 1건 당 `드리븐 테이블`을 반복해서 검색하는 방식   
```sql
select 학생.학번, 학생.이름, 비상연락망.관계, 비상연락망.연락처
from 학생
JOIN 비상연락망
	ON 학생.학번 = 비상연락망.학번
WHERE 학생.학번 IN (1, 100);
```
- 위 쿼리에서 PK, 인덱스가 사용되지 않은 경우 NL Join 절차 (학생 테이블 100건, 비상연락망 1000건)
  - 학생 테이블에서 학번이 1을 찾기 위해 학생 테이블 풀스캔 (100건)
  - 학생 테이블에서 조회된 학번 1로 비상연락망 테이블 풀스캔 (1000건)
  - 위 작업을 학번 100에 대해 반복
  - 총 2200건의 데이터 접근이 발생

#### 블록 중첩 루프 조인 (BNL, block nested loop join)
- `드라이빙 테이블`에 인덱스가 존재하고 `드리븐 테이블`에 인덱스가 없는 경우 중첩 루프 조인을 수행하면 `드라이빙 테이블`의 결과만큼 `드리븐 테이블`을 풀스캔해야 하는 비효율이 발생한다.
- 블록 중첩 루프 조인은 위와 같은 문제를 `조인 버퍼`를 도입해서 해결한다.
- 블록 중첩 루프 조인 수행 절차
1. `드라이빙 테이블`의 결과를 버퍼의 크기만큼 `조인 버퍼`에 적재한다.
2. `조인 버퍼`가 가득차면 버퍼의 데이터를 `드리븐 테이블`과 조인한다.
3. `드라이빙 테이블`을 모두 조회할 때까지 1,2를 반복한다.
- `드리븐 테이블`이 인덱스의 부재로 풀스캔으로 성능이 저하되는 것을 개선하는 조인 알고리즘이다.

#### 배치 키 액세스 조인 (BKA, batched ky access join)
- 중첩 루프 조인 방식은 필연적으로 데이터 접근 시 랜덤 엑세스가 발생한다.
  - 즉, 데이터 범위가 넓다면 비효율적인 조인방식이 된다.
- `배치 키 액세스 조인` 은 랜덤 엑세스의 비효율을 해결하고자 하는 조인 알고리즘이다.
- `드라이브 테이블`은 블록 중첩 루프 조인의 `조인 버퍼` 개념을 그대로 사용한다.
- 추가로 `드리븐 테이블`에서 필요한 데이터를 예측해서 정렬된 상태로 담는 `랜덤 버퍼`의 개념을 도입한다.
  


































