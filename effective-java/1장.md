## 2장 - 객체 생성과 파괴
- 객체를 마들어야 할 때와 만들지 말아야 할 때를 구분하는 법
- 올바른 객체 생성 방법과 불필요항 생성을 피하는 방법
- 제때 파괴됨을 보장하고 파괴 전 수행할 작업을 관리하는 요령

***

### 생성자 대신 정적 팩터리 메서드를 고려하라
- 전통적으로 클래스 인스턴스를 얻는 수단은 public 생성자이다.
- 클래스는 Public 생성자 대신 혹은 함께 정적 팩터리 메서드를 제공할 수 있다.

#### 팩터리 메서드의 장점
1. 이름을 가질 수 있다.
- 생성자의 경우 반환될 객체의 특성을 제대로 설명하지 못한다.
- 정적 팩터리 메서드의 경우 메서드의 이름으로 반환될 객체의 특성을 묘사할 수 있다.

2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
- 불변 클래스의 경우 인스턴스를 미리 만들어 놓거나 새로 생성된 인스턴스를 캐싱해서 사용하는 방식을 사용할 수 있다.

3. 반환 타입의 하위 타입 객체를 반환할 수 있다.
- 자바8부터 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸다.
- 인터페이스로 정적 팩터리 메서드를 구현하여 다형성을 가진 타입을 제공한다.

4. 입력 매개변수에 따라 매번 다른 클래스 객체를 반환할 수 있다.
- 클라이언트는 팩터리가 반환하는 객체가 어떤 클래스의 인스턴스인지 알 필요가 없다.

5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
- 인터페이스나 부모 클래스가 만들어지는 시점에 하위 타입의 클래스가 존재하지 않아도 일단 팩터리 메서드는 만들어 놓고 이후 만들어진 하위 클래스가 같은 인터페이스나 클래스를 구현 또는 상속한다면 주입받아서 사용할 수 있다.

#### 팩터리 메서드의 단점
1. 정적 팩터리 메서드만으로는 하위 클래스를 만들 수 없다.
- 상속을 하려면 public 또는 protected 생성자를 필요로 한다.

2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
- 생성자처럼 API 설명에 명확하게 드러나지 않는다.
- 아직까지는 팩터리 메서드에 대한 문서 자동화가 이루어지지 않기 때문에 정적 팩터리 메서드의 명명 방식을 잘 따르며 문서를 유지하는 것이 중요하다.

***

### 생성자에 매개변수가 많다면 빌더를 고려하라
- 정적 팩터리 메서드와 생성자 모두 선택적 매개변수가 많을 때 대응하기 어렵다.
- 선택적 매개변수에 해당하는 모든 부분을 `점층적 생성자 패턴`으로 만들 수 있지만 매개변수의 수가 많아진다면 가독성이 떨어진다.
```java
// 점층적 생성자 패턴 ex
public Aclass(int a){
	this(a, 0, 0);
}

public AClass(int a, int b){
	this(a, b, 0);
}

public AClass(int a, int b, int c) {
	this.a = a;
	this.b = b;
	this.c = c;
}
```
- `점층적 생성자 패턴`의 단점을 해결하기 위해 `자바 빈즈` 패턴을 도입할 수 있다.
- `자바 빈즈`는 기본생성자를 통해 빈 인스턴스를 생성하고 `setter`를 통해 값을 세팅하는 방식이다.
- `자바 빈즈`를 사용하면서 `점층적 생성자 패턴`보다는 단순한 생성자를 갖고 가독성도 올렸지만 여전히 문제가 있다.
- 객체 하나를 생성하기 위해 여러 번의 메서드 호출이 필요하고, 객체 생성을 위한 `setter` 호출동안 객체의 일관성이 보장되지 않는다.
- `점층적 생성자 패턴`의 안정성과 `자바 빈즈`의 가독성을 겸비한 `빌더 패턴`을 사용할 수 있다.

```java
// 빌더패턴 ex
public class ClassA {
	private final int a;
	private final int b;
	private final int c;
	private final int d;

	public static class Builder {
		private final int a; // 필수
		private final int b; // 필수

		private int c = 0; // 선택적 매개변수 
		private int d = 0;

		public Builder(int a, int b) {
			this.a = a;
			this.b = b;
		}

		public Builder c(int val) {
			this.c = val;
			return this;
		}
		public Builder d(int val) {
			this.d = val;
			return this;
		}

		public ClassA build() {
			return new ClassA(Builder builder);
		}
	}

	private ClassA(Builder builder) {
		this.a = builder.a;
		this.b = builder.b;
		this.c = builder.c;
		this.d = builder.d;
	}
}

// 빌더패턴 사용 ex
ClassA classA = new ClassA.Builder(100, 50)
							.c(0).d(10).build();
```

***

### private 생성자나 열거 타입으로 싱글턴임을 보장하라

싱글턴을 만드는 세 가지 방식
- private 생성자 + public final static 인스턴스
```java
public class ClassA {
	public static final ClassA INSTANCE = new ClassA();
	private ClassA() {...}
}
```  
- private 생성자 + 정적 팩터리 메서드 (getInstance)
```java
public class ClassA {
	private static final ClassA INSTANCE = new ClassA();
	private ClassA() {...}

	public static ClassA getInstance() {
		return INSTANCE;
	}
}
```
- 원소가 하나인 열거 타입 방식 싱글턴 (대부분의 상황에서 가장 좋은 방법)
```java
public enum ClassA {
	INSTANCE;
}
```

***

### 인스턴스화를 막으려거든 private 생성자를 사용하라
- 정적 멤버만 담는 유틸리티 클래스는 인스턴스 생성을 위해 만들어진 클래스가 아니다.
- 인스턴스 생성을 의도하지 않기 때문에 생성자를 명시하지 않게 되는데 이때 컴파일러가 자동으로 기본 생성자를 만들게 된다.
- 컴파일러가 자동으로 생성한 기본 생성자는 클라이언트 입장에서 의도한 것인지 의도하지 않은 것인지 구분할 수 없다.

> 추상 클래스로 만드는 것은 인스턴스화를 막을 수 없다.

- 인스턴스화를 막기 위해 해당 클래스를 추상 클래스로 만드는 것은 방법이 될 수 없다. 하위 클래스를 만들어서 생성하면 된다.
- `abstract` 라는 키워드를 보고 클라이언트는 `상속해서 사용하라는 거구나.` 라고 생각할 수 있기 때문이다.

> private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.

***

### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- 어떤 클래스는 다른 클래스에 의존할 수 있다. (다른 클래스의 참조를 갖는 형태)
- 의존하는 클래스를 final로 사용하지 않고 필요에 따라 `setter` 등으로 변경해가며 사용할 수 있다.
  - 단, 이 방법은 멀티쓰레드 환경에서 사용할 수 없다.

> 인스턴스를 생성할 때 필요한 자원(의존성)을 넘겨주는 방식을 사용하자.

```java
public class ClassA {
	private final ClassB classB;

	public ClassA(ClassB classB) {
		this.classB = Objects.requireNonNull(classB);
	}
}
```

***

### 불필요한 객체 생성을 피하라
- 같은 기능을 수행하는 객체를 매번 생성하기보다는 객체를 하나만 생성하고 재사용하는 편이 나을 때가 많다.
- 불변 객체의 경우 언제든 재사용할 수 있다.
```java
// 실행될 때마다 새로운 String 인스턴스를 만드는 경우
String s = new String("str");
```
- 위와 같은 형태가 반복문이나 빈번히 호출되는 메서드 안에 위치한다면 쓸데없이 String 인스턴스가 계속해서 만뜰어질 수도 있다.
```java
// 매번 인스턴스가 생성되지 않는 개선된 버전
String s = "str";
```
- 위 코드는 매번 `new`를 통해 String 인스턴스를 생성하지 않는다.

> 불변 클래스의 경우 정적 팩터리 메서드를 사용하면 불필요하면 객체 생성을 피할 수 있다.

```java
// X
Boolean b = new Boolean("true");

// O
Boolean b = Boolean.valueOf("true");
```
- `Boolean`의 경우 `Boolean(String)`과 같이 생성자를 통해 생성하는 것보다 `Boolean.valudOf(String)`을 사용하는 것이 좋다.


> 오토박싱 (auto boxing)
오토박싱은 기본타입과 박싱된 기본 타입(래퍼런스 타입)을 섞어 쓸 때 자동으로 상호 변환해주는 기술이다.
오토방식은 기본타입과 래퍼런스 타입의 구분을 흐려주지만 완전히 없애주지는 않는다.

```java
private static long sum() {
	Long sum = 0L;
	for (long i=0; i<=Integer.MAX_VALUE; i++) {
		sum += i;
	}
	return sum;
}
```
- 위 코드는 의도한 대로 정상적으로 동작하지만 성능저하 요인이 있다.
- 값을 누적하는 변수인 sum을 `long`타입이 아닌 `Long` 타입으로 한 것이 문제이다.
  - `long` 타입인 i가 `Long` 타입에 더해질 때마다 `Long` 타입 인스턴스가 불필요하게 생성된다.
- 위와 같은 문제가 발생하지 않도록 가능하면 래퍼런스 타입보다는 기본 타입을 사용하도록 해야 한다.
  - 의도치 않은 `오토박싱`을 피하기 위해 기본타입을 권장하는 것이다.

***

### 다 쓴 객체 참조를 해제하라
- C, C++과 같이 메모리를 직접 관리하는 언어도 있지만 Java의 경우 가비지 컬렉터에게 많은 부분이 맡겨져서 개발자에게 편의를 가져다준다.    
  - 다 쓴 객체를 알아서 회수해가는 등 ...
  - 이런 편의는 모든 것을 맡겨도 된다는 오해로 이어질 수 있다.

```java
// 메모리 누수가 존재하는 코드
public class Stack{
	private Object[][] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;

	public Stack() {
		elements = new Object[DEFAULT_INITIAL_CAPACITY];
	}

	public void push(Object e) {
		ensureCapacity();
		elements[size++] = e;
	}

	public Object pop() {
		if (size == 0) {
			throw new EmptyStackException();
		}
		return elements[--size];
	}

	private void ensureCapacity() {
		if (elemtns.length == size) {
			elements = Arrays.copyOf(elements, 2*size+1);
		}
	}
}
```    



































