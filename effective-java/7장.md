## 7장 람다와 스트림

<br>

### 익명 클래스보다는 람다를 사용하라

자바8 이전 익명 클래스의 사용
```java
Collections.sort(list, new Comparator<String>() {
	pubilc int compare(String s1, String s2) {
		return Integer.compare(s1.length(), s2.length());
	}
});
```

자바8에 와서 *추상 메서드가 하나만 있는 인터페이스*는 `람다식`을 사용할 수 있게 됐다.
```java
Collections.sort(list, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

`비교자 생성 메서드`를 사용해서 더 간결한 코드를 만들 수 있다.
```java
Collections.sort(list, comparingInt(String::length));
```

이전에 열거형 타입을 다룰 때 각 상수마다 달리 동작하게 하는 방법 중 하나로 열거타입에 추상 메서드 하나를 두는 방식이 있었다.
```java
public enum Operation {

	PLUS {public double apply(double x, double y) {return x + y}},
	MINUS {public double apply(double x, double y) {return x - y}},
	TIMES {public double apply(double x, double y) {return x / y}},
	DIVIDE {public double apply(double x, double y) {return x * y}};

	public abstract double apply(double x, double y);
}
```
위 enum 클래스도 하나의 추상메서드만 가지고 있으므로 람다식을 적용할 수 있다.

```java
public enum Operation {

	PLUS {(x, y) -> x + y);}
	...

	public abstract double apply(double x, double y);
}
```

***

### 람다보다는 메서드 참조를 사용하라

람다를 이용해서 익명 클래스를 사용할 때 가장 큰 이점은 간결함이다.
이를 더 간결하게 사용할 수 있는 것이 `메서드 참조` 이다.

```java
// Map.merge
// key가 map에 없다면 key와 1을 매핑
// key가 map에 있다면 기존 key에 매핑된 값을 증가

// 람다 ver
map.merge(key, 1, (count, incr) -> count + incr);

// 메서드 참조 ver
map.merge(key, 1, Integer::sum);
```

`람다`의 사용이 불가능한 곳에는 `메서드 참조`도 사용할 수 없다.
보통의 경우 `메서드 참조`가 보다 간결함을 제공하기도 하지만 반대의 경우도 있다
```java
// 메서드 참조 ver
service.execute(GoshThisClassNameIsHumongous::action);

// 람다 ver
service.execute(() -> action());
```

> 메서드 참조는 람다의 대안이 될 수 있고 보다 간결한 코드를 제공할 수 있다. 만약 메서드 참조가 보다 명확하고 간결하다면 메서드 참조를 고려하자.

***

### 표준 함수형 인터페이스를 사용하라

> 함수형 인터페이스
`1개의 추상 메서드`를 갖는 인터페이스를 말한다.
자바 8부터 인터페이스에서 `디폴트 메서드`를 제공한다.
`함수형 인터페이스`는 `여러 개 디폴트 메서드`를 갖더라도 `추상 메서드는 한 개만` 가진다.
(`default`, `static` 메서드 OK)

> @FunctionalInterface
`@FunctionalInterface`를 사용하면 현재 인터페이스가 함수형 인터페이스의 조건을 갖추었는지 검사할 수 있다.

람다의 등장으로 상위 클래스의 기본 클래스를 재정의해서 원하는 동작을 구현하는 `템플릿 메서드 패턴`의 매력이 크게 줄었다.

`템플릿 메서드 패턴`과 같은 구조를 `함수 객체를 받는 정적 팩터리나 생성자`를 제공하는 것으로 구현 가능하다.

> 함수 객체를 매개변수로 받는 생성자와 메서드를 많이 만들어야 한다.

<br>

`java.util.function`에 이미 여러 *표준 함수형 인터페이스*가 담겨있다.
함수형 인터페이스를 직접 구현하는 것보다는 이미 존재하는 *표준 함수형 인터페이스*를 사용하자.









































