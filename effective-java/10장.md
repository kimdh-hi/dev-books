## 10장 예외

<br>

### 예외는 진짜 예외 상황에만 사용하라

**예외를 잘못 사용한 예**
```java
try {
	int i = 0;
	while (true) 
		range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {...}
```
- `range`라는 배열을 무한루프를 돌며 순회하는데 순회의 종료 조건을 예외로 하고 있다.
- 배열의 경우 매번 범위에 대한 검사를 수행한다. 
  `ArrayIndexOutOfBoundsException`가 발생하는 경우 순회를 종료하는 것이다.

위 코드를 사용한 이유가 나름 있을 수 있지만 일단 가독성이 떨어지고 일반적인 for문을 사용하는 것보다 느리다고 한다. 굳이 사용할 이유가 없는 것이다.

#### 예외는 오직 예외상황에서만 써야 한다. 절대 일상적인 제어 흐름용으로 쓰지 말자.
#### 클라이언트의 정상적 요청으로 정상적 제어 흐름이 흘러가는 중에 예외가 발생할 일이 없게 해야 한다.

***

### 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

`CheckedExcetpion`, `RuntimeException`, `Error`를 언제 사용해야 하는가?

#### 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.
- 위 규칙이 검사, 비검사 예외를 구분하는 **기본 규칙**이다.
- 검사 예외를 던지면 호출한 쪽에서 `try-catch`로 처리하거나 `throws`로 밖으로 전파시킨다.
- **검사예외** : 해당 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 알려주는 것

#### 비검사 - 런타임 예외, 에러
- 두 예외는 잡을 필요가 없거나 잡지 말아야 한다.
- **비검사 예외**나 **에러**가 던져진 것은 복구가 불가능하거나 더 실행하는 것에 의미가 없다는 것이다.
- 에러를 잡거나 복구하는 대신 오류 메시지를 던지며 **중단**된다.

#### 프로그래밍 오류를 나타날 때는 런타임 예외를 사용하자.
- `런타임 예외`는 대부분 클라이언트가 API의 명세를 지키지 못했을 때 발생한다.
  ex) `ArrayIndexOutOfBoundsException`


어떤 조건에서 문제로 예외가 발생했을 때 복구할 수 있는 상황인지 그렇지 않은 상황인지 명확히 구분하기 힘들 수 있다.

**자원 고갈**의 경우 너무 큰 크기의 배열을 할당해서 생긴 프로그래밍 오류일 수 있고 정말 자원이 부족해서 발생한 문제일 수도 있다.

만약 순간적으로 자원이 몰린 것 때문에 발생하는 상황이라면 복구 가능할 것이다.
하지만 애초에 너무 큰 크기의 배열이 할당되서 발생했다면 이후 복구할 여지가 없다.

복구가 가능하다면? **검사 예외**
복구가 가능하지 않다면? **런타임 예외**

#### 직접 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.
- `Error`는 상속해서 예외 클래스를 만드는 것은 자제하자.
- 이는 널리 퍼진 규약이다.
- `Error`는 상속하지 말고 `throw`로 던지지도 말자.

#### throwable 은 언제 사용하면 좋은가?
- 사용하지 말자.
- `throwable` 은 정상적인 검사 예외보다 좋은게 없다. 그냥 사용하지 말자.


> 정리
복구 가능한 상황 => 검사 예외
프로그래밍 오류 => 비검사 예외 (RuntimeException)
애매하다면 => 비검사 예외
검사 예외도 런타임 예외도 아니라면 `throwable`은 사용하지 말자

***

### 필요 없는 검사 예외 사용은 피하라
- **검사 예외**는 발생한 문제를 클라이언트가 처리하게 하여 안전성을 높일 수 있다.
- **but,** 과한 **검사 예외**의 사용은 API를 사용하기 불편하게 할 수 있다.
  호출하는 쪽에서 `try-catch` 또는 `throws`를 강제하기 때문이다.
- 검사 예외를 던지는 API는 스트림 안에서 직접 사용할 수 없다..

API를 제대로 사용해도 발생할 수 있는 예외나 의미있는 조치가 가능한 경우가 아니라면
**비검사 예외** 를 사용하자.


#### 검사 예외를 회피하는 가장 쉬운 방법
- 적절한 결과 타입을 담은 `Optional`을 반환하는 것
  `검사예외` 대신 `빈 Optional`을 반환하는 것이다.
- `검사예외`를 회피할 수 있지만 어떤 예외인지에 대한 정보를 담을 수 없다.

#### 검사 예외를 발생하는 메서드르 2개로 쪼개 비검사 예외로 바꾸는 방법
첫번째 메서드에서 **예외가 발생할 지에 대한 여부**를 `boolean`으로 반환   

```java
// 검사예외를 그대로 던지는 메서드
try {
	obj.action(args);
} catch (TheCheckedException e) {
	// 예외처리 ...
}

// 메서드의 상태를 검사하고 비검사 예외를 던지는 메서드
if (obj.actionPermitted(args)) {
	obj.action(args);
} else {
	// 예외처리 ...
}
```

모든 상황에서 메서드의 예외발생 가능 상황을 검사할 수는 없지만 가능하다면 적용하여 편한 API를 만들 수 있다.

> 정리
**검사 예외**는 API의 안전성을 높여준다.
하지만 API를 사용하기 불편하게 만든다. (try-catch, throws ㅠㅠ)
호출하는 쪽에서 예외를 복구할 방법이 없다면 **비검사 예외**를 던져주자.
예외에 대해 호출자가 어떤 처리를 해주길 바란다면 우선 **빈 Optional**을 반환해도 될지 고민하자.
예외에 대한 충분한 정보를 전달해야 한다면 **검사예외**를 던지자.

***



























































