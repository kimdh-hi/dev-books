## 제네릭

- 제네릭은 자바 5부터 지원됐다.
- 제네릭 이전에는 컬렉션에서 값을 꺼낼 때마다 알맞은 타입으로 형변환이 필요했다.
- 제네릭은 컬렉션이 받을 수 있는 타입을 컴파일러에게 알려준다.
- 컴파일러는 제네릭 정보를 토대로 다른 타입에 대해 컴파일 에러를 발생시킬 수 있고 자동으로 형변환을 수행할 수 있게 되었다.

### raw 타입은 사용하지 말라

- 제네릭 타입을 정의하면 `raw type`도 함께 정의된다.
- `raw type`은 제네릭 타입에서 타입 매개변수를 사용하지 않는 때를 말한다.
  - `List<E>`의 raw type은 `List`

> raw type을 사용하는 경우 데이터 삽입은 되지만 런타임에 데이터를 조회 후 캐스팅하는 과정에서 예외가 발생할 수 있다. (예외는 컴파잁 타임에 발생되는 것이 가장 좋다.)

> raw type은 자바 5 이전의 코드들과의 호환성을 위해 존재하는 것이다. 지금 쓰라고 남아있는 것은 아니다.

***

## 비검사 경고를 제거하라

제네릭을 사용하게 되면 컴파일 시점에 컴피일로부터 많은 경고를 받게 될 것이다.
가능한 한 모든 비검사 경고를 제거해야 한다.

경고를 제거할 수 없지만 안전한 타입임을 확신한다면 `@SuspressWarnings("unchecked")` 를 사용해서 경로를 수길 수 있다.

> 단, `@SuspressWarnings`는 가능한 한 좁은 범위에 사용하자.

`@SuspressWarnings`는 클래스 단위부터 변수 단위까지 적용가능하다.
클래스 레벨에 추가하는 것은 너무 넓은 범위의 경로를 무시하게 된다. 변수, 생성자, 짧은 메서드 정도로 사용을 제한하자.

***

## 배열보다는 리스트를 사용하라

- 리스트는 컴파일 타임에 타입에러를 잡을 수 있다.
```java
Object[] arr = new Long[1];
arr[0] = "str"; // 컴파일 OK, 런타임에 ArrayStoreException을 던진다.

List<Object> list = new ArrayList<Long>();
list.add("str"); // 컴파일 에러 발생
```

- 배열의 경우 런타임까지 타입에 대한 정보를 인지하고 확인한다.
- 리스트(제네릭)의 경우 컴파일 타임에 타입에 대한 정보를 인지 및 확인하고 런타임에는 소거한다.
  - 런타임에는 그냥 로 타입처럼 사용된다는 뜻인 것 같다.


> 배열과 리스트를 혼용하다가 컴파일 에러를 만나게 되면 배열을 리스트로 바꾸는 방법을 적용해보자.

***





























